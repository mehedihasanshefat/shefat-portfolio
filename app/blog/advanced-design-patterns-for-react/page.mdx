export const metadata = {
  title: "Advanced Design Patterns for React.js",
  description:
    "Master advanced React design patterns including render props, compound components, hooks patterns, and more",
  date: "23-12-2025",
  author: "Mehedi Hasan Shefat",
};

<div className="mb-4">
  <a
    href="/blog"
    style={{
      textDecoration: "none",
    }}
    className={
      "inline-flex items-center rounded-md border border-input px-6 h-10 text-sm font-medium hover:bg-accent/5 underline-offset-4"
    }
  >
    Back To Blogs
  </a>
</div>

![Advanced Design Patterns for React](/images/blogs/design-patterns.PNG)

# Advanced Design Patterns for React.js

## Introduction

React has revolutionized frontend development, and with it came a new set of design patterns unique to component-based architecture. While most developers understand basic patterns like props and state, advanced patterns separate good React developers from great ones.

In this comprehensive guide, we'll explore advanced patterns that solve real-world problems, improve code maintainability, and elevate your React development skills.

## 1. Render Props Pattern

The render props pattern allows you to share stateful logic by passing a function as a prop. Instead of wrapping a component, you pass a function that returns JSX.

### Basic Render Props

```javascript
// ❌ Bad: Hard to reuse logic
class MouseTracker extends React.Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (event) => {
    this.setState({ x: event.clientX, y: event.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove}>
        <p>
          Mouse position: {this.state.x}, {this.state.y}
        </p>
      </div>
    );
  }
}

// ✅ Good: Reusable with render props
class Mouse extends React.Component {
  state = { x: 0, y: 0 };

  handleMouseMove = (event) => {
    this.setState({ x: event.clientX, y: event.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove}>
        {this.props.render(this.state)}
      </div>
    );
  }
}

// Usage
function App() {
  return (
    <Mouse
      render={({ x, y }) => (
        <div>
          <p>
            Mouse at ({x}, {y})
          </p>
          <Cat x={x} y={y} />
        </div>
      )}
    />
  );
}
```

### Real-World Example: Form Logic

```javascript
// Reusable form handling with render props
class FormHandler extends React.Component {
  state = {
    values: {},
    errors: {},
    touched: {},
    isSubmitting: false
  };

  handleChange = (event) => {
    const { name, value, type, checked } = event.target;
    this.setState(prevState => ({
      values: {
        ...prevState.values,
        [name]: type === 'checkbox' ? checked : value
      }
    }));
  };

  handleBlur = (event) => {
    const { name } = event.target;
    this.setState(prevState => ({
      touched: { ...prevState.touched, [name]: true }
    }));
  };

  handleSubmit = async (onSubmit) => (event) => {
    event.preventDefault();
    this.setState({ isSubmitting: true });

    try {
      await onSubmit(this.state.values);
    } catch (error) {
      this.setState({ errors: { submit: error.message } });
    } finally {
      this.setState({ isSubmitting: false });
    }
  };

  render() {
    return this.props.render({
      values: this.state.values,
      errors: this.state.errors,
      touched: this.state.touched,
      isSubmitting: this.state.isSubmitting,
      handleChange: this.handleChange,
      handleBlur: this.handleBlur,
      handleSubmit: this.handleSubmit
    });
  }
}

// Usage
<FormHandler
  render={(formProps) => (
    <form onSubmit={formProps.handleSubmit((values) => submitForm(values))}>
      <input
        name="email"
        value={formProps.values.email}
        onChange={formProps.handleChange}
        onBlur={formProps.handleBlur}
      />
      {formProps.touched.email && formProps.errors.email && (
        <span>{formProps.errors.email}</span>
      )}
      <button disabled={formProps.isSubmitting}>Submit</button>
    </form>
  )}
/>
```

## 2. Compound Component Pattern

Compound components are a set of components that work together as a single unit, sharing implicit state.

### Basic Compound Component

```javascript
// ❌ Bad: Rigid API
function Tabs(props) {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <div>
      <div className="tabs">
        {props.tabs.map((tab, i) => (
          <button
            key={i}
            onClick={() => setActiveTab(i)}
            className={activeTab === i ? "active" : ""}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div className="content">{props.tabs[activeTab]?.content}</div>
    </div>
  );
}

// ✅ Good: Compound component pattern
const TabsContext = createContext();

function Tabs({ children, defaultValue = 0 }) {
  const [activeTab, setActiveTab] = useState(defaultValue);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs-container">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function TabButton({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);

  return (
    <button
      onClick={() => setActiveTab(value)}
      className={activeTab === value ? "active" : ""}
    >
      {children}
    </button>
  );
}

function TabContent({ value, children }) {
  const { activeTab } = useContext(TabsContext);

  return activeTab === value ? <div>{children}</div> : null;
}

// Usage - Much more flexible
<Tabs defaultValue={0}>
  <TabList>
    <TabButton value={0}>Tab 1</TabButton>
    <TabButton value={1}>Tab 2</TabButton>
    <TabButton value={2}>Tab 3</TabButton>
  </TabList>

  <TabContent value={0}>Content 1</TabContent>
  <TabContent value={1}>Content 2</TabContent>
  <TabContent value={2}>Content 3</TabContent>
</Tabs>;
```

### Advanced Compound Component with Validation

```javascript
// Accordion component with compound pattern
const AccordionContext = createContext();

function Accordion({ children }) {
  const [expandedId, setExpandedId] = useState(null);

  return (
    <AccordionContext.Provider value={{ expandedId, setExpandedId }}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
}

function AccordionItem({ id, children }) {
  return <div className="accordion-item">{children}</div>;
}

function AccordionTrigger({ id, children }) {
  const { expandedId, setExpandedId } = useContext(AccordionContext);

  return (
    <button
      onClick={() => setExpandedId(expandedId === id ? null : id)}
      className={expandedId === id ? "expanded" : ""}
    >
      {children}
    </button>
  );
}

function AccordionContent({ id, children }) {
  const { expandedId } = useContext(AccordionContext);

  return expandedId === id ? <div className="content">{children}</div> : null;
}

// Usage
<Accordion>
  <AccordionItem id="1">
    <AccordionTrigger id="1">Section 1</AccordionTrigger>
    <AccordionContent id="1">Content for section 1</AccordionContent>
  </AccordionItem>

  <AccordionItem id="2">
    <AccordionTrigger id="2">Section 2</AccordionTrigger>
    <AccordionContent id="2">Content for section 2</AccordionContent>
  </AccordionItem>
</Accordion>;
```

## 3. Higher-Order Component (HOC) Pattern

HOCs wrap a component and enhance it with additional functionality.

### Basic HOC

```javascript
// ✅ HOC for adding theme
function withTheme(Component) {
  return function ThemedComponent(props) {
    const [theme, setTheme] = useState("light");

    return (
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Component {...props} />
      </ThemeContext.Provider>
    );
  };
}

const ThemedApp = withTheme(App);
```

### Advanced HOC: Authentication Wrapper

```javascript
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
      fetchUser()
        .then((user) => {
          setUser(user);
          setIsLoading(false);
        })
        .catch((err) => {
          setError(err);
          setIsLoading(false);
        });
    }, []);

    if (isLoading) return <Spinner />;
    if (error) return <ErrorBoundary error={error} />;
    if (!user) return <LoginPage />;

    return <Component {...props} user={user} />;
  };
}

// Usage
const ProtectedDashboard = withAuth(Dashboard);
```

### HOC with Display Name for Debugging

```javascript
function enhance(Component) {
  class Enhance extends React.Component {
    render() {
      return <Component {...this.props} />;
    }
  }

  // For debugging in React DevTools
  Enhance.displayName = `Enhance(${getDisplayName(Component)})`;

  return Enhance;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
}
```

## 4. Custom Hooks Pattern

Custom hooks are JavaScript functions that use React hooks and extract component logic.

### Basic Custom Hook

```javascript
// ✅ Custom hook for managing form state
function useForm(initialValues, onSubmit) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues((prev) => ({ ...prev, [name]: value }));
  };

  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched((prev) => ({ ...prev, [name]: true }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      await onSubmit(values);
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    setValues,
    setErrors,
  };
}

// Usage
function LoginForm() {
  const form = useForm({ email: "", password: "" }, async (values) => {
    await api.login(values);
  });

  return (
    <form onSubmit={form.handleSubmit}>
      <input
        name="email"
        value={form.values.email}
        onChange={form.handleChange}
      />
      <button disabled={form.isSubmitting}>Login</button>
    </form>
  );
}
```

### Advanced Custom Hook: useAsync

```javascript
function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState("idle");
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  const execute = useCallback(async () => {
    setStatus("pending");
    setData(null);
    setError(null);

    try {
      const response = await asyncFunction();
      setData(response);
      setStatus("success");
      return response;
    } catch (err) {
      setError(err);
      setStatus("error");
      throw err;
    }
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, data, error, isLoading: status === "pending" };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, status, error } = useAsync(() => fetchUser(userId), true);

  if (status === "pending") return <div>Loading...</div>;
  if (status === "error") return <div>Error: {error.message}</div>;
  if (!user) return null;

  return <div>{user.name}</div>;
}
```

### Custom Hook: useLocalStorage

```javascript
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value) => {
      try {
        const valueToStore =
          value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}

// Usage
function ThemeSwitcher() {
  const [theme, setTheme] = useLocalStorage("theme", "light");

  return (
    <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      Current theme: {theme}
    </button>
  );
}
```

## 5. State Management Patterns

### Context + useReducer for Complex State

```javascript
// ✅ Scalable state management
const AppStateContext = createContext();
const AppDispatchContext = createContext();

const initialState = {
  user: null,
  isAuthenticated: false,
  theme: "light",
  notifications: [],
  loading: false,
};

function appReducer(state, action) {
  switch (action.type) {
    case "LOGIN_SUCCESS":
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        loading: false,
      };

    case "LOGOUT":
      return {
        ...state,
        user: null,
        isAuthenticated: false,
      };

    case "SET_THEME":
      return { ...state, theme: action.payload };

    case "ADD_NOTIFICATION":
      return {
        ...state,
        notifications: [...state.notifications, action.payload],
      };

    case "REMOVE_NOTIFICATION":
      return {
        ...state,
        notifications: state.notifications.filter(
          (n) => n.id !== action.payload
        ),
      };

    default:
      return state;
  }
}

function AppProvider({ children }) {
  const [state, dispatch] = useReducer(appReducer, initialState);

  return (
    <AppStateContext.Provider value={state}>
      <AppDispatchContext.Provider value={dispatch}>
        {children}
      </AppDispatchContext.Provider>
    </AppStateContext.Provider>
  );
}

// Custom hooks to use context
function useAppState() {
  const context = useContext(AppStateContext);
  if (!context) {
    throw new Error("useAppState must be used within AppProvider");
  }
  return context;
}

function useAppDispatch() {
  const context = useContext(AppDispatchContext);
  if (!context) {
    throw new Error("useAppDispatch must be used within AppProvider");
  }
  return context;
}

// Usage
function Navbar() {
  const { user, isAuthenticated } = useAppState();
  const dispatch = useAppDispatch();

  const handleLogout = () => {
    dispatch({ type: "LOGOUT" });
  };

  return (
    <nav>
      {isAuthenticated ? (
        <>
          <span>{user.name}</span>
          <button onClick={handleLogout}>Logout</button>
        </>
      ) : (
        <a href="/login">Login</a>
      )}
    </nav>
  );
}
```

## 6. Lazy Loading Pattern

```javascript
// Code splitting with React.lazy
const Dashboard = React.lazy(() => import("./Dashboard"));
const AdminPanel = React.lazy(() => import("./AdminPanel"));
const Analytics = React.lazy(() => import("./Analytics"));

function App() {
  const [currentPage, setCurrentPage] = useState("dashboard");

  return (
    <Suspense fallback={<LoadingSpinner />}>
      {currentPage === "dashboard" && <Dashboard />}
      {currentPage === "admin" && <AdminPanel />}
      {currentPage === "analytics" && <Analytics />}
    </Suspense>
  );
}

// With route-based code splitting
import { Suspense, lazy } from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";

const Home = lazy(() => import("./pages/Home"));
const About = lazy(() => import("./pages/About"));
const Contact = lazy(() => import("./pages/Contact"));

function AppRouter() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/contact" element={<Contact />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## 7. Memoization Patterns

### useMemo for Expensive Computations

```javascript
function FilteredUserList({ users, searchTerm }) {
  // This computation only runs when users or searchTerm changes
  const filteredUsers = useMemo(() => {
    console.log("Filtering users...");
    return users.filter((user) =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);

  return (
    <ul>
      {filteredUsers.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### useCallback for Stable Function References

```javascript
function Parent() {
  const [count, setCount] = useState(0);

  // This callback maintains the same reference across renders
  const handleChildClick = useCallback(() => {
    console.log("Child clicked");
  }, []); // Empty dependencies - callback never changes

  return <Child onClickCallback={handleChildClick} />;
}

function Child({ onClickCallback }) {
  return <button onClick={onClickCallback}>Click me</button>;
}
```

## 8. Error Handling Patterns

### Error Boundary

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    console.error("Error caught:", error, errorInfo);
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h1>Something went wrong</h1>
          <p>{this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <App />
</ErrorBoundary>;
```

### Async Error Handling Hook

```javascript
function useAsyncError() {
  const [, setError] = useState();

  return useCallback(
    (error) => {
      setError(() => {
        throw error;
      });
    },
    [setError]
  );
}

function ComponentWithAsyncError() {
  const throwAsyncError = useAsyncError();

  useEffect(() => {
    fetchData().catch((error) => throwAsyncError(error));
  }, [throwAsyncError]);

  return <div>Component</div>;
}
```

## 9. Dependency Injection Pattern

```javascript
// Decouple components from dependencies
const APIContext = createContext();

function APIProvider({ children, apiClient }) {
  return (
    <APIContext.Provider value={apiClient}>{children}</APIContext.Provider>
  );
}

function useAPI() {
  const context = useContext(APIContext);
  if (!context) {
    throw new Error("useAPI must be used within APIProvider");
  }
  return context;
}

// Easy to swap implementations for testing
function UserService() {
  const api = useAPI();

  const fetchUser = async (id) => {
    return api.get(`/users/${id}`);
  };

  return { fetchUser };
}

// Usage
const mockAPI = {
  get: jest.fn(),
};

render(
  <APIProvider apiClient={mockAPI}>
    <App />
  </APIProvider>
);
```

## 10. Container/Presentational Component Pattern

```javascript
// Container Component: Logic
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUsers()
      .then(setUsers)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  const handleDelete = async (userId) => {
    await deleteUser(userId);
    setUsers(users.filter((u) => u.id !== userId));
  };

  return (
    <UserListPresentation
      users={users}
      loading={loading}
      error={error}
      onDelete={handleDelete}
    />
  );
}

// Presentational Component: UI
function UserListPresentation({ users, loading, error, onDelete }) {
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      <h1>Users</h1>
      <ul>
        {users.map((user) => (
          <UserItem
            key={user.id}
            user={user}
            onDelete={() => onDelete(user.id)}
          />
        ))}
      </ul>
    </div>
  );
}
```

## 11. Composition Over Inheritance

```javascript
// ✅ Composition: Flexible and reusable
function Button({ children, variant = "default", ...props }) {
  const baseClasses = "px-4 py-2 rounded font-semibold";
  const variantClasses = {
    default: "bg-blue-500 text-white",
    secondary: "bg-gray-300 text-black",
    danger: "bg-red-500 text-white",
  };

  return (
    <button className={`${baseClasses} ${variantClasses[variant]}`} {...props}>
      {children}
    </button>
  );
}

// Compose into new components
function PrimaryButton(props) {
  return <Button variant="default" {...props} />;
}

function DangerButton(props) {
  return <Button variant="danger" {...props} />;
}

// Further composition
function ConfirmButton({ onConfirm, ...props }) {
  const [isConfirming, setIsConfirming] = useState(false);

  if (isConfirming) {
    return (
      <div>
        <p>Are you sure?</p>
        <DangerButton onClick={onConfirm}>Yes, delete</DangerButton>
        <Button onClick={() => setIsConfirming(false)}>Cancel</Button>
      </div>
    );
  }

  return <DangerButton onClick={() => setIsConfirming(true)} {...props} />;
}
```

## 12. Props Validation and TypeScript

```typescript
// TypeScript for type safety
interface UserProps {
  id: number;
  name: string;
  email: string;
  role: "admin" | "user" | "guest";
  isActive: boolean;
  metadata?: Record<string, unknown>;
}

interface UserCardProps extends UserProps {
  onEdit?: (user: UserProps) => void;
  onDelete?: (id: number) => void;
}

const UserCard: React.FC<UserCardProps> = ({
  id,
  name,
  email,
  role,
  isActive,
  onEdit,
  onDelete,
}) => {
  return (
    <div>
      <h3>{name}</h3>
      <p>{email}</p>
      <span>{role}</span>
      <button onClick={() => onEdit?.({ id, name, email, role, isActive })}>
        Edit
      </button>
      <button onClick={() => onDelete?.(id)}>Delete</button>
    </div>
  );
};
```

## Performance Considerations

### Memoization Best Practices

```javascript
// Use memo wisely
const UserCard = React.memo(function UserCard({ user, onSelect }) {
  console.log("UserCard rendered:", user.id);
  return <div onClick={() => onSelect(user)}>{user.name}</div>;
});

// Custom comparison
const UserCardWithCustomComparison = React.memo(
  UserCard,
  (prevProps, nextProps) => {
    return prevProps.user.id === nextProps.user.id;
  }
);
```

### Lazy Evaluation

```javascript
// Bad: Computes on every render
const expensive = complexCalculation();

// Good: Only computes when dependencies change
const expensive = useMemo(() => complexCalculation(), [dependencies]);
```

## Conclusion

Mastering these advanced patterns will make you a more effective React developer:

1. **Render Props**: Share component logic through functions
2. **Compound Components**: Build flexible, composable components
3. **Higher-Order Components**: Enhance components with additional functionality
4. **Custom Hooks**: Extract and reuse component logic
5. **Context + Reducer**: Manage complex global state
6. **Lazy Loading**: Optimize bundle size with code splitting
7. **Memoization**: Prevent unnecessary re-renders
8. **Error Boundaries**: Handle errors gracefully
9. **Dependency Injection**: Decouple and simplify testing
10. **Container/Presentational**: Separate concerns cleanly
11. **Composition**: Build flexible systems
12. **TypeScript**: Ensure type safety

Remember: **Don't use a pattern just because it exists**. Choose patterns that solve real problems in your application.

---

_Last updated: December 23, 2024_

<div className="mt-4">
  <a
    href="/blog"
    style={{
      textDecoration: "none",
    }}
    className={
      "inline-flex items-center rounded-md border border-input px-6 h-10 text-sm font-medium hover:bg-accent/5 underline-offset-4"
    }
  >
    Back To Blogs
  </a>
</div>
