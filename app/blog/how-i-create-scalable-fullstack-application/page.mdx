export const metadata = {
  title: "How I Create Scalable Fullstack Applications",
  description:
    "A practical walkthrough of building scalable fullstack apps using React, Next.js, TypeScript, Tailwind, Prisma, PostgreSQL, MongoDB, Redis, Clerk, Arcjet and more",
  date: "23-12-2025",
  author: "Mehedi Hasan Shefat",
};

<div className="mb-4">
  <a
    href="/blog"
    style={{
      textDecoration: "none",
    }}
    className={
      "inline-flex items-center rounded-md border border-input px-6 h-10 text-sm font-medium hover:bg-accent/5 underline-offset-4"
    }
  >
    Back To Blogs
  </a>
</div>

![Scalable Fullstack Cover](/images/blogs/scalable-application.png)

# How I Create Scalable Fullstack Applications

Building systems that scale reliably requires both architecture discipline and careful technology choices. This post lays out the patterns, tools, and real decisions I use when designing and implementing fullstack apps that serve real users and scale gracefully.

## High-level principles

- Start with the simplest thing that works; iterate with telemetry.
- Separate concerns: UI, API, background-workers, storage, and infra.
- Make correctness and observability defaults: logging, metrics, tracing, errors.
- Design for failure: retries, circuit breakers, graceful degradation.
- Optimize for developer velocity with strong types, clear patterns, and automation.

## Core stack (what I use and why)

- **React (frontend)** — composable UI, fast iteration, ecosystem for state and rendering patterns.
- **Next.js (app router)** — SSR/SSG, streaming, routing, fullstack patterns (API / server actions), and edge support.
- **TypeScript** — static types to catch bugs early and improve DX.
- **Tailwind CSS** — utility-first styling for consistent design and fast iteration.
- **Prisma ORM** — type-safe database access and migrations; works well with Postgres and (now) MongoDB.
- **PostgreSQL** — primary relational datastore for transactional data.
- **MongoDB** — document store for schemaless or high-write parts (optional, used when a flexible schema is needed).
- **Redis** — caching, distributed locks, rate-limiting, session store, and background job broker.
- **React Hook Form + Zod** — fast, accessible form handling and runtime validation with static types.
- **Authentication**: **Clerk** (hosted auth) or **better-auth/Arcjet** style custom flows — pick hosted for speed or custom for deep control.
- **Background jobs / Workers** — use Redis-backed queues (BullMQ / Bree) or serverless jobs depending on scale.
- **Observability** — Sentry for errors, Prometheus/Grafana for metrics, and OpenTelemetry tracing.

## Example architecture (single-region, horizontally scalable)

```
Users -> CDN (images, assets) -> Next.js (edge + server nodes)
                             │
                   Load Balancer / Edge
                             │
     ┌──────────────┬────────┴────────┬──────────────┐
     │             API / Server-side Render Nodes       │
     │       (Next.js + Node/Edge functions)           │
     │                                                │
     └──────────────┬────────┬────────┬───────────────┘
                    │        │        │
                Postgres   Redis   Background Workers
               (Prisma)   (cache,   (BullMQ, jobs,
                          sessions)   emails, tasks)
                    │
                Storage (S3/Blob) for files and images
```

For global scale you add multi-region DB replicas, global CDN, and regional caches.

## Folder structure I recommend (Next.js + app folder)

```
app/
  layout.tsx
  page.tsx
  api/
    auth/route.ts
    posts/route.ts
  (feature folders)
components/
  ui/
  forms/
  layout/
lib/
  prisma.ts
  db.ts
  validators.ts
  auth.ts
hooks/
  useAuth.ts
  useSWR.ts
prisma/
  schema.prisma
package.json
```

## Backend: Prisma + PostgreSQL (example)

Prisma gives typed DB access and migration tooling. Example `schema.prisma` snippet for Postgres:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  posts     Post[]
}

model Post {
  id        String   @id @default(cuid())
  title     String
  body      String
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  String?
  createdAt DateTime @default(now())
}
```

Prisma client usage in `lib/prisma.ts`:

```ts
import { PrismaClient } from "@prisma/client";

declare global {
  // allow hot-reload in dev to not create multiple clients
  var prisma: PrismaClient | undefined;
}

export const prisma = global.prisma ?? new PrismaClient();
if (process.env.NODE_ENV !== "production") global.prisma = prisma;
```

## When to use MongoDB

- Use MongoDB for flexible documents (activity feeds, schema-less ingest, or analytics pipelines).
- Prisma has Mongo support; or use native driver for advanced features.
- Keep relational data (transactions, payments) in Postgres.

## Authentication patterns: Clerk vs custom

- **Clerk**: Quick to integrate, handles sessions, MFA, OAuth providers, and user management.
  - Great for shipping fast with secure defaults.
- **Custom (better-auth / Arcjet)**: Use when you need full control (custom token flows, custom session stores, or advanced federation).
  - Use JWTs or opaque sessions (store session in Redis) and rotate secrets regularly.

Example using Clerk (server components):

```ts
// app/api/auth/route.ts
import { auth } from "@clerk/nextjs";

export async function GET(req: Request) {
  const { userId } = auth();
  if (!userId) return new Response("Unauthorized", { status: 401 });
  return new Response(JSON.stringify({ userId }));
}
```

## Forms, validation, and type-safety

- Use **React Hook Form** for performant uncontrolled forms.
- Use **Zod** for runtime validation and type inference from schemas.

Example:

```tsx
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

type LoginForm = z.infer<typeof schema>;

function LoginForm() {
  const { register, handleSubmit, formState } = useForm<LoginForm>({
    resolver: zodResolver(schema),
  });

  const onSubmit = (data: LoginForm) => {
    // call API
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("email")} />
      <input type="password" {...register("password")} />
      <button disabled={formState.isSubmitting}>Sign in</button>
    </form>
  );
}
```

This flow keeps UI, types, and runtime validation in sync.

## Caching & performance

- Use Redis for:
  - Response caching (short TTL) and cache warming
  - Session store for opaque sessions
  - Rate limiting and distributed locks
  - Pub/sub for real-time notifications
- Use CDN (Vercel, Cloudflare, S3 + CloudFront) for static asset delivery
- Use Next.js Image optimization, asset size budgets, and bundle analysis

Example cache-get pattern:

```ts
const cached = await redis.get(cacheKey);
if (cached) return JSON.parse(cached);

const fresh = await fetchFromDb();
await redis.set(cacheKey, JSON.stringify(fresh), "EX", 60); // 60s
return fresh;
```

## Background jobs and workers

- Offload heavy or retryable tasks (email, image processing, exports) to background workers.
- I use BullMQ / Redis or serverless queue jobs depending on reliability needs.

## Realtime and queues

- Use WebSockets / server-sent events for realtime UI where needed.
- Use Redis pub/sub or a managed solution (Pusher, Supabase Realtime) for fan-out.

## Security best-practices

- Use HTTPS everywhere and HSTS headers.
- Properly scope and rotate secrets via a secrets manager.
- Use prepared statements / parameterized queries (Prisma does this for you).
- Limit third-party scripts and sanitize user-generated content.
- Use rate-limiting and IP throttles for sensitive endpoints.

## Dev DX: local, CI, and migrations

- Use `dotenv` for environment variables; prefer tools like Direnv or CLI secrets for local dev safety.
- Run Prisma migrations in CI or via a controlled promotion step.

CI pipeline (example):

1. Run lint, typecheck, and unit tests
2. Run schema checks and generate Prisma client
3. Build frontend (Next.js), run integration tests
4. Deploy to staging
5. Smoke test, then promote to production

## Observability & SLOs

- Track error rate, latency (p95/p99), and throughput.
- Set SLOs for availability and latency, alert on burn rate.
- Add request-level tracing (OpenTelemetry) for diagnosing distributed calls.

## Example Next.js API handler (edge-safe)

```ts
// app/api/posts/route.ts (Next.js app router)
import { prisma } from "@/lib/prisma";

export async function GET() {
  const posts = await prisma.post.findMany({
    take: 20,
    orderBy: { createdAt: "desc" },
  });
  return new Response(JSON.stringify(posts), { status: 200 });
}

export async function POST(req: Request) {
  const body = await req.json();
  // validate with Zod
  // create with Prisma
}
```

## Scaling notes

- Horizontal scale for stateless Next.js nodes behind a load balancer.
- Use connection pooling (PgBouncer) and read replicas for Postgres.
- Partitioning and sharding strategy for large datasets.
- Cache invalidation strategy: event-driven invalidation is usually preferable.

## Cost & ops trade-offs

- Managed services (Clerk, Supabase, Vercel, PlanetScale, RDS) speed up delivery but cost more.
- Self-hosting yields control and lower per-unit cost at scale but higher ops overhead.
- Choose managed services early for MVP; optimize later with measurable bottlenecks.

## Closing checklist (practical)

- [ ] Types for all external API contracts
- [ ] Runtime validation for user input (Zod)
- [ ] Test coverage for critical flows
- [ ] Telemetry: traces, logs, metrics
- [ ] CI/CD with migrations and rollbacks
- [ ] Rate-limits and quotas on public endpoints
- [ ] Redis for caching and job coordination
- [ ] Background workers for heavy tasks

---

_Last updated: December 23, 2024_

<div className="mt-4">
  <a
    href="/blog"
    style={{
      textDecoration: "none",
    }}
    className={
      "inline-flex items-center rounded-md border border-input px-6 h-10 text-sm font-medium hover:bg-accent/5 underline-offset-4"
    }
  >
    Back To Blogs
  </a>
</div>
